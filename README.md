# ЭФФЕКТИВНЫЕ КОСОЭРМИТОВЫ ПРЕОБУСЛОВЛИВАТЕЛИ ДЛЯ РЕШЕНИЯ СЕДЛОВЫХ ЗАДАЧ

## Введение

В курсовой работе рассматриваются эффективные косозермитовы предусловители, тема в рамках итерационных методов для систем с линейными алгебраическими уравнениями. Предусловливание остается ключевым этапом в процессе решения, особенно при работе с сельдовыми задачами.

## Содержание

- **Реализация на Python:** практическое кодовое представление обсуждаемых концепций.
- **Документ LaTeX:** теоретические объяснения и математические выводы.

## Установка и требования

1. Убедитесь, что у вас установлен Python 3.x.
2. Установите необходимые библиотеки с помощью `pip install -r requirements.txt` (убедитесь, что у вас есть `numpy` и `scipy`).

## Использование

1. Запустите основной скрипт Python: `python main.py`.

## Вклад

Не стесняйтесь делать форк репозитория и отправлять запросы на слияние. Для крупных изменений сначала откройте вопрос, чтобы обсудить предлагаемое изменение.

Тема курсовой работы: "Эффективные косоэрмитовы предобусловители для решения седловых задач". Мы изучили ряд источников, включая статью из базы данных eLibrary (https://elibrary.ru/item.asp?id=48040805), и на основе этого разработали алгоритм для решения систем линейных алгебраических уравнений (СЛАУ), применимый к седловым задачам. Наш алгоритм способен решать СЛАУ при заданных параметрах, и мы установили конкретные ограничения для этих параметров, чтобы обеспечить корректное решение.
 
Мы планируем демонстрировать, как варьирование параметров \( H0, w, t \) влияет на сходимость решения седловых СЛАУ, а также как меняется время сходимости в зависимости от размеров матриц и выбранных параметров. Нас интересует, будет ли такого подхода достаточно для успешной защиты курсовой работы?

# A = None #Матрица n*n из комплексных чисел
# v = None
# b = None

# #A*v==b
# Bm1 = None

# def check_for_obusl(X):
#     return None

# #print(check_for_obusl(Bm1*A)>check_for_obusl(A))
# #Bm1*A*v==Bm1*b

# #A_star = make_A_star(A) #сопряжённо-транспонированную (или эрмитову сопряжённую
# A_star = None


# is_positive_definite(A)



# A0 = 0.5*(A + A_star)
# A1 = 0.5*(A - A_star)
# A == A0+A1